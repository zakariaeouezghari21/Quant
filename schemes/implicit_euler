# Backward Euler scheme implementation 
# theta = 1.0

class ImplicitEulerScheme:

    def __init__(self, mapOperator, bc, tol, solverType):
        self.dt_ = None
        self.iterations_ = 0
        self.mapOperator_ = mapOperator
        self.bc_ = bc
        self.tol_ = tol
        self.solverType_ = solverType

    def apply(self, u, theta):
        return u - (theta * self.dt_) * self.mapOperator_.apply(u)
    
    def step(self, u, t):
        self.step_with_theta(u, t, 1.0)
    
    def step_with_theta(self, u, t, theta):
        if t - self.dt_ < -1e-8:
            raise ValueError("a step towards negative time is not allowed.")
        
        self.mapOperator_.setTime(max(0.0, t - self.dt_), t)
        self.bc_.setTime(max(0.0, t - self.dt_))

        self.bc_.applyBeforeSolving(self.mapOperator_, u)
        
        if self.mapOperator_.size() == 1:
            u[:] = self.mapOperator_.solve_splitting(0, u, -theta * self.dt_)
        else:
            def preconditioner(_u):
                return self.mapOperator_.preconditioner(_u, -theta * self.dt_)

            def applyF(_u):
                return self.apply(_u, theta)
            
            if self.solverType_ == "BiCGstab":
                result = BiCGstab(applyF, max(10, len(u)), self.tol_, preconditioner).solve(u, u)
                self.iterations_ += result.iterations
                u[:] = result.x
            elif self.solverType_ == "GMRES":
                result = GMRES(applyF, max(10, len(u) // 10), self.tol_, preconditioner).solve(u, u)
                self.iterations_ += len(result.errors)
                u[:] = result.x
            else:
                raise ValueError("unknown solver type")

        self.bc_.applyAfterSolving(u)
        
    def setStep(self, dt):
        self.dt_ = dt
    
    def numberOfIterations(self):
        return self.iterations_
    